{% extends "blog/blog_header.html" %}
{% block content %}
{% load staticfiles %}


<div class="container-fluid">
  <h3>Introduction to R</h3>
  <h4> Part 1: Base R and Basic Packages</h4>
  <h4><span style="color: #D5518D" id="author">By </span><span style="color: #3E95D7" id="name">Arun Ramamurthy</span>  </h4>
  <br />
  <h4>Introduction</h4>
  <p>
	In this first tutorial on R, you will learn about how to actually use R to work with data, as well as the core concepts behind R programming. You will learn the basics of R syntax as well as several functions in base R. Finally, you will grow familiarity with R Markdown, especially as you work within the r1-workbook associated workbook.
  </p>
  <br />
  <h4>About this Document</h4>
  <h5>Prerequisites</h5>
  <p>
  	The only prerequisite for this tutorial is <a href="https://susa.berkeley.edu/blog/installing-r-and-rstudio">r0</a>. You will need to install both R and RStudio to use the r1-workbook associated workbook. Visit <a href="https://susa.berkeley.edu/blog/installing-r-and-rstudio">r0</a> for general information on the philosophy and functionality of R and RStudio, as well as installation guides for both.
  </p>
  <br/>
  <h5>r1</h5>
  <p>
  	This document contains textbook-style information on R programming. It will cover the essentials of both base R and a few packages such as <code>magrittr</code> and <code>stringr</code>.
  </p>
  <br />
  <h5>r1-workbook</h5>
  <p>
  	The r1-workbook contains associated exercises to work through as you learn about the concepts within this document. They are aimed to help you get practice and familiarity with R programming concepts and functions. At the end of each section of this document, solve the problems in the matching section of the workbook to help your understanding of the material.
  </p>
  <br />
  <h4>R Markdown</h4>
  	<p>The associated workbook requires some knowledge of R Markdown to use.</p>
  	<br/>
  	<p>
  		<strong>R Markdown</strong> is a powerful way to combine text, code, code output, images, LaTeX, and web elements into a single document, report, slide deck, or website. R Markdown is a file format and markup language that allows you to <strong>knit</strong> together <code>Rmd</code> files, which can either be <em>interactive</em> (as <strong>notebooks</strong>), or <em>published</em> (like this <code>html</code> document). It allows you to break up your code into bite-sized <strong>code chunks</strong>, surrounded by (optionally marked up) text. See the Additional Reading section at the end of this document for more information on how to make your own beautiful reports and workbooks in R! As R Markdown documents are standalone and work regardless of the computer that opens them, they are the best way to edit and share statistical code.
  	</p>
  	<br />
  	<p>
  		At the very core of the notebook philosophy is the <strong>code chunk</strong>. To make a chunk in RStudio, simply type three backticks, <code>{R}</code>, and then three more backticks when you are finished writing your code chunk. An example of the chunk syntax is below: 
  	</p>
  	#insert picture here
  	<h4>Base R</h4>
  	<p>
  		Base R (known as the <code>base</code> package internally) contains hundreds of functions by default to jumpstart your data analysis workflow. We will go over the syntax of R, as well as some of these functions.
  	</p>
  	<br />
  	<h4>Basic R</h4>
  	<h5>Syntax Basics</h5>
  	<p>
  		R is <em>case-sensitive</em>. So, ensure that you are always using the correct capitalization when dealing with functions, variables, and dataframe column names.<br />
  		Additionally, every command is separated by a new line, or a semicolon if you want to make multiple commands on a single line. <br />
  		Finally, you can comment code with #, which requests that R ignore the entire rest of the line, and treat it as normal text in the output.
  	</p>
  	<br />
  	<h5>Expressions</h5>
  	<p>You can do basic arithmetic in R without the need of more advanced functions. These operations include the EMDAS (<code>^</code>, <code>*</code>, <code>/</code>, <code>+</code>, <code>-</code> respectively) operators, as well as the modulo/remainder operator (<code>%%</code>). Some examples are below:
  	</p>
  	<pre class="python"><code>2 ^ 3</code></pre>
  	<pre class="python"><code>4 * 4</code></pre>
  	<pre class="python"><code>5 / 10</code></pre>
  	<pre class="python"><code>3 + 3</code></pre>
  	<pre class="python"><code>7 - 6</code></pre>
  	<pre class="python"><code>8 %% 6</code></pre>
  	<p>
  		We can also use the equality operator (<code>==</code>) and the inequality operator (<code>!=</code>), as well as operators like greater-than (<code>></code>) and less-than-or-equal (<code><=</code>) to test values. (To <strong>test</strong> means to return <code>TRUE</code> in some cases and <code>FALSE</code> otherwise). Some examples are below:
  	</p>
  	<pre class="python"><code>4 > 4</code></pre>
  	<pre class="python"><code>4 >= 4</code></pre>
  	<pre class="python"><code>4 == 4</code></pre>
  	<pre class="python"><code>4 != 4</code></pre>  	
  	<p>
  		Note that spaces between operators and operands are optional, but may improve readability.
  	</p>
  	<h5>Variables & Assignment</h5>
  	<p>
  		In R, a <strong>variable</strong> is an object that stores a value of some sort. After assigning a variable an initial value, you can re-assign it as many time as you'd like, even changing the type of object it stores. <br />
		The most basic way to assign a variable a value in R is to use the <code>=</code> operator, which sets a variable to the value to its right. However, you can also use the <strong>arrow operator</strong> to set variables on either the left or the right of the value. <br />
		As such, the following are equivalent:
  	</p>
  	<pre class="python"><code>a = 1</code></pre>
  	<pre class="python"><code>a <- 1</code></pre>
  	<pre class="python"><code>1 -> a</code></pre>
  	<p>
  		After you have set a variable, you can <code>print</code> its value using print. Alternatively, you can just type the variable to see its value.
  	</p>
  	<pre class="python"><code>print(a)</code></pre>
  	<pre class="python"><code>a</code></pre>
  	<p>
  		Once you have set a variable, you can use it in arithmetic! For example, let's emulate the Pythagorean Formula.
  	</p>
  	<pre class="python"><code>a <- 3</code></pre>
  	<pre class="python"><code>b <- 4</code></pre>
  	<pre class="python"><code>c <- sqrt(a^2 + b^2)</code></pre>
  	<pre class="python"><code>c</code></pre> 
  	<p>
  		Normally, R will not let you start a variable with a number or include any spaces in your variable name. To get around this, surround your variable with backticks.
  	</p>
  	<pre class="python"><code>`5 and a space` <- 420</code></pre>
  	<pre class="python"><code>print(`5 and a space`)</code></pre> 
  	<h4>Atomic Objects</h4>
  	<p>
  		An <strong>atomic</strong> object in R is an object or list of objects that are both <strong>flat</strong> (cannot be reduced or opened further) and of the same <strong>type</strong>.<br />
	
		There are three <strong>types</strong> in R - we will be going over their properties individually, before discussing vectors, which are collections of atomic objects. To check the type of an object, use the <code>mode</code> function:
	</p>
  	<pre class="python"><code>mode(1.23)</code></pre> 
  	<h4>Types</h4>
  	<h5>Numerics</h5>
  	<p>
  		A <strong>numeric</strong> is an atomic object that refers to integers, doubles (<em>decimals</em>), and more.<br />

		Some examples are below:
  	</p>
  	<pre class="python"><code>13</code></pre> 
  	<pre class="python"><code>013</code></pre> 
  	<pre class="python"><code>0130</code></pre>
  	<pre class="python"><code>1.30</code></pre> 
   	<pre class="python"><code>13e-1</code></pre> 
   	<p>R also contains the constant <code>pi</code>, which evaluates to 3.141593.</p>
   	<h5>Logicals</h5>
   	<p>
   		A <strong>logical</strong> is a quantity that evaluates to either <code>TRUE</code> or <code>FALSE</code>. Recall the (in)equality testing we reviewed above - the output of these operators are logicals. <br/>

		Any non-zero numeric evaluates to <code>TRUE</code>. You can also use <code>T</code> and <code>F</code> rather than <code>TRUE</code> and <code>FALSE</code>, respectively. <br/>

		The <strong>boolean</strong> operators in R are operators that have logicals as operands. There are three basic ones:
   	</p>
   	<ul>
   		<li><code>|</code> the binary OR operator, which returns <code>TRUE</code> if either of its arguments are <code>TRUE</code></li>
   		<li><code>&</code> the binary AND operator, which returns <code>TRUE</code> if both of its arguments are <code>TRUE</code></li>
   		<li><code>!</code> the unary NOT operator, which returns the opposite of its logical operand</li>
   	</ul>
   	<h5>Characters</h5>
   	<p>
   		A single lexographical symbol or <strong>string</strong> of multiple symbols is of type <strong>character</strong>. To make a string, surround one or more symbols in double-quotes (or alternatively, in single-quotes). A string does not evaluate its contents, and so <code>"TRUE"</code> and <code>"123"</code> are distinct from <code>TRUE</code> and <code>123</code>. Observe the functionality of various basic string syntaxes and functions below:
   	</p>
   	<pre class="python"><code>str <- "susa"; nchar(str)</code></pre> 
   	<pre class="python"><code>str2 <- "1.2"; str2 == 1.2</code></pre> 
   	<pre class="python"><code>str3 <- paste("Statistics", "Undergraduate", "Students", "Association"); print(str3)</code></pre> 
   	<h4>Vectors</h4>
   	<p>
		A <strong>vector</strong> is an ordered finite sequence of elements, each of the same type. Just like the atomic objects it contains, a vector is also considered an atomic object*. As such, they must be both <strong>flattened</strong> (fully reduced) and of the <strong>same type</strong>. Vectors are an important building block in R, as they compute quickly and are a way to bind together multiple values.<br/>

		*(<em>In fact, singleton values are just single-element vectors in R.</em>)
   	</p>
   	<h5>Vector Basics</h5>
   	<p>
   		To construct a vector, we use the <code>c</code> function, which stands for <em>concatenate</em>, as it can also add more values to the vector. You can also use the <code>:</code> notation to make ordered sequences of numbers. Finally, you can check the length of a vector using <code>length</code>. Observe these behaviors below:
   	</p>   	
   	<pre class="python"><code>vec <- c(1,2,3,4)</code></pre>
   	<pre class="python"><code>vec2 <- 1:4</code></pre>
   	<pre class="python"><code>print(vec)</code></pre>
   	<pre class="python"><code>length(vec2)</code></pre>
   	<pre class="python"><code>vec === vec2</code></pre>
   	<h5>Vectorized Functionality</h5>
   	<p>
   		Notice that operators (e.g. <code>==</code>) function on vectors <em>element-wise</em>. This is an example of R's <strong>vectorization</strong> behavior. Essentially, R will try to take basic operators and functions and apply it to each element in a vector automatically, then return the resultant vector. Because of vectorization, vector operation in R is efficient. Here are some examples of vectorization in R:
   	</p>
   	<pre class="python"><code>v <- c(1, 12, 169, 7)</code></pre>
   	<pre class="python"><code>1/v</code></pre>
   	<pre class="python"><code>2*v^2 - v + 3</code></pre>
   	<h5>Flattening</h5>
   	<p>
   		Recall from the previous section that atomic objects are always <em>flattened</em>. That is, they cannot contain non-atomic objects. When you combine two vectors in R with <code>c</code>, they will automatically become one long vector, rather than a 2-element vector of two vectors. To better illustrate this, observe the following examples of <em>flattening</em>:
   	</p>
   	<pre class="python"><code>v <- 1:5</code></pre>
   	<pre class="python"><code>c(1,2,3,v)</code></pre>
   	<pre class="python"><code>c(1:3, v)</code></pre>
   	<pre class="python"><code>w <- c(v, v)</code></pre>
   	<pre class="python"><code>length(w)</code></pre>
   	<pre class="python"><code>w</code></pre>

   	<p>
   		An example of both properties of atomic objects (<em>flattening</em> and <em>same-typeness</em>) is that R will automatically <strong>cast</strong> elements of different types to be the type. Logicals will turn into numerics, and both numerics and logicals will turn into strings if R has to convert them to retain <em>same-typeness</em>. Consider the following example of this behavior:
   	</p>
    <pre class="python"><code>a <- v(T, F)</code></pre>
    <pre class="python"><code>c(a, 3)</code></pre>
   	<pre class="python"><code>c(a, "TREE")</code></pre>

	<h5>Subsetting Vectors</h5>
	<p>
		All vectors are <strong>indexed</strong> (labeled by number) so that you can access them by telling R which elements you want. The indicies are <em>1-indexed</em> - i.e. the first element is labeled <code>1</code>, the second <code>2</code>, and so on. You can specify which elements with square brackets. Finally, you can tell R to <em>exclude</em> rather than select the indices you pass to it using <code>-</code>. Observe the following behaviors:
	</p>
	<pre class="python"><code>v <- c("red", "blue", "green")</code></pre>
    <pre class="python"><code>v[1]</code></pre>
   	<pre class="python"><code>v[2]</code></pre>
   	<pre class="python"><code>v[1:2]</code></pre>
    <pre class="python"><code>v[-2]</code></pre>
   	<pre class="python"><code>v[-c(3,1,2)]</code></pre>

   	<p>Alternatively, you can specify an inclusion indicator for each element by giving a vector of logicals. Observe the following behaviors:</p>
   	<pre class="python"><code>v <- 1:5</code></pre>
    <pre class="python"><code>v[c(T, F, F, F, T)]</code></pre>
   	<pre class="python"><code>v[! c(T, F, T, F, T)]</code></pre>

   	<p>Finally, if you set <strong>names</strong> for the elements of your vector, you can access the elements in your <strong>named</strong> vector by giving which specifying you want. Observe the following behaviors:
   	</p>
   	<pre class="python"><code>v <- c(one = 1, two = 2, three = 3)</code></pre>
    <pre class="python"><code>v["one"]</code></pre>
   	<pre class="python"><code>get_these <- c("one", "three")</code></pre>
   	<pre class="python"><code>v[get_these]</code></pre>

   	<h4>Lists</h4>
   	<p>
   		Now let's learn a few <em>non-atomic</em> objects. A <strong>list</strong> is an ordered sequence of values of <em>flexible type</em>. In comparison to vectors, lists are unconstrained in what they can contain. Their elements can be of different type or even be vectors or lists themselves! To access elements of a list, use single square brackets to get a sublist, or <strong>extract</strong> a single value with double bracket.s Observe the following behaviors:
   	</p>
   	<pre class="python"><code>vec <- 3:1</code></pre>
    <pre class="python"><code>1  <- list("SUSA", vec, c(F, T)); 1</code></pre>
   	<pre class="python"><code>length(1)</code></pre>
   	<pre class="python"><code>1[2] #[] returns a sublist</code></pre>
   	<pre class="python"><code>1[2:3]</code></pre>
    <pre class="python"><code>1[[2]] #[[]] returns the item within the list</code></pre>

    <h4>Functions</h4>
    <p>
    	Now that you've learnt some of the basic data structures in R, let's learn some of the <strong>functions</strong> that operate on them! A <strong>function</strong> is a device that accepts zero or more input <strong>arguments</strong> and yields single output, or <strong>result</strong>. Unlike the binary and unary operators (e.g. <code>+</code>, <code>==</code>, etc.) we've been reading about, functions have the following usage syntax: <code>f(x,y)</code>, just like functions you study in math class.
    </p>
    <h5>Using Functions</h5>
    <p>Let's learn a couple of functions that should help illustrate how functions work in R. First up, we have the <code>sqrt</code> function, which simply finds the square root of its argument. Observe the following behavior:</p>
    <pre class="python"><code>sqrt(4)</code></pre>
    <pre class="python"><code>sqrt(23)</code></pre>
   	<pre class="python"><code>real_negative = -1; sqrt(real_negative)</code></pre>
   	<pre class="python"><code>complex_negative = as.complex(-1); sqrt(complex_negative)</code></pre>

   	<p>
   		<em>Notice that <code>sqrt(-1)</code> returns <code>NaN</code>("Not a Number") for real -1, but returns i for complex -1.</em>
   	</p>
   	<br />
	<p>
		To check how a function works in R, simply type e.g. <code>?sqrt</code> in your console. The associated documentation for the function you searched will open up in the Help pane. You will see a <strong>Description</strong> section, which discusses the function's purpose in English; a <strong>Usage</strong> section, which shows you the right syntax to use the function; a <strong>Arguments</strong> section, which details what kinds of objects will be accepted as arguments; a <strong>Details</strong> section, which explains special cases and considerations; and an <strong>Examples</strong> sections which gives example code segments on how to use the function in question. 
	</p>
	<br />
	<p>
	Some functions have <strong>default values</strong> for some arguments. For example, if you type <code>?log</code>, you will see information on R's log function. Notice that the default base is <code>base = exp(1)</code>. That is, if we use <code>log</code> in R, by default it will take the natural log. If we wanted to change the base, we could specify it as something else than its default value. Finally, note that many functions in R (e.g. <code>log</code>), also support vectorization. Observe the following examples:
   	</p>
	<pre class="python"><code>tens <- 10^(1:10)</code></pre>
    <pre class="python"><code>log(tens)</code></pre>
    <pre class="python"><code>log(tens, base = 10)</code></pre>
    <pre class="python"><code>log(tens, base = 2)</code></pre>

    <h5>Writing Functions</h5>
    <p>
		To write your own function in R, we will use curly brackets, the <code>function</code> function, and the <code>return</code> function. For example, to make a function <code>square</code> that returns the 2nd power of its inputted argument, we can run:
	</p>
	<pre class="python"><code>square <- function(x){return(x^2)}</code></pre>
	<p>
		Then, we can use the <code>square</code> function anytime we wish. Since the contents of the <code>square</code> function uses the vectorized operator <code>^</code>, our <code>square</code> function is vectorized too.
	</p>
	<pre class="python"><code>square(12)</code></pre>
	<pre class="python"><code>square(1:10)</code></pre>
	<p>
		Suppose we also wanted to make a more general function <code>power</code>, that will raise a number to the $n^{th}$ power, but default to just squaring a number. We could write it as so:
	</p>
	<pre class="python"><code>power <- function(x, n = 2){return(x^n)}</code></pre>
	<p>Observe the following behaviors of our handmade function:</p>
	<pre class="python"><code>power(12)</code></pre>
	<pre class="python"><code>power(12, n = 5)</code></pre>
	<pre class="python"><code>power(1:10)</code></pre>
	<pre class="python"><code>power(1:10, n = 1/2)</code></pre>
	<p>
		Finally, if you want to use multple functions together, you can <strong>compose</strong> them just like you do in math (e.g. <code>f(g(x))</code>). We will later learn about a package called <code>magrittr</code> that makes reading function compositions much easier. Observe the following examples:
	</p>
	<pre class="python"><code>sqrt(square(12))</code></pre>
	<pre class="python"><code>sqrt(power(12))</code></pre>
	<pre class="python"><code>sqrt(power(12, n = 3))</code></pre>

	<h4>Dataframes</h4>
	<p>
		Now that we've learnt about vectors, lists, and functions, we are ready to learn about the most essential object for data analysis: the <strong>dataframe</strong>. A dataframe is a list of (named) vectors, all of the same length.
	</p>
	<h5>Constructing Dataframes</h5>
	<p>
		For example, let's suppose we wanted to make a dataframe of a group of friends, with their ages and favorite colors. First, we would make a vector of their names, a vector of their ages, and a vector of their favorite colors. Notice that these vectors are of different types, but all contain exactly 3 elements:
	</p>
	<pre class="python"><code>friends <- c("Hadley", "Mom", "R"); class(friends)</code></pre>
	<pre class="python"><code>ages <- c(30, 45, 18); class(ages)</code></pre>
	<pre class="python"><code>fav_colors <- c("Pink", "Yellow", "Blue"); class(fav_colors)</code></pre>
	<p>
		Then, we can combine these into a dataframe, or list of named vectors, using the <code>data.frame</code> function. Alternatively, we can first make a list of vectors, and then give it as an argument to <code>data.frame</code> to acheive the same thing:
	</p>
	<pre class="python"><code>my_friends <- data.frame(Name = friends, Age = ages, `Favorite Color` = fav_colors, check.names = F)</code></pre>
	<pre class="python"><code>print(my_friends)</code></pre>
	<pre class="python"><code>my_friends_2_precursor <- list(Name = friends, Age = ages, `Favorite Color` = fav_colors)</code></pre>
	<pre class="python"><code>my_friends_2 <- data.frame(my_friends_2_precursor, check.names = F)</code></pre>
	<pre class="python"><code># my_friends is identical to my_friends_2</code></pre>
	<p>
		R has constructed a dataframe called <code>my_friends</code> with three column vectors, <code>Name</code>, <code>Age</code>, and <code>Favorite Color</code>. We can check the <strong>structure</strong> of our dataframe with the <code>str</code> command, which details the number of <strong>observations</strong> (<em>rows</em>) and the number of <strong>variables</strong> (<em>columns</em>), as well as the type of each:
	</p>
	<pre class="python"><code>str(my_friends)</code></pre>
	<p>
		Notice that <code>data.frame</code> converted our string vectors (<code>friends</code>, <code>fav_colors</code>) into factor vectors. A <strong>factor</strong> is a new type that refers to categorical data with a finite number of categories. R prefers to work with factors, as it makes checking equality and sorting faster than if it had to parse strings. R will implicitly convert strings into factors, unless you ask it not to by specifying <code>stringsAsFactors=FALSE</code> in the function call of <code>data.frame</code>.
	</p>
	<h5>Subsetting Dataframes</h5>
	<p>
		To extract a specific vector back out of a dataframe, use <code>$</code> notation. Alternatively, you can use the standard list double square-bracket notation:
	</p>
	<pre class="python"><code>vec <- my_friends$Name</code></pre>
	<pre class="python"><code>print(vec)</code></pre>
	<pre class="python"><code>vec2 <- my_friends[[1]]</code></pre>
	<pre class="python"><code>vec == vec2)</code></pre>
	<p>
		Finally, you can <strong>subset</strong> your dataframe to return a new dataframe with only particular columns or rows with the single square-bracket notation:
	</p>
	<pre class="python"><code>my_friends[1, ]</code></pre>
	<pre class="python"><code>my_friends[, 3]</code></pre>
	<pre class="python"><code>my_friends[1,3]</code></pre>
	<h4>RDS Files</h4>
	<p>
		An <strong>RDS</strong> (<em>R Data Structure</em>) is the most efficient way to make your dataframes portable. It simply packages whatever object you pass to the <code>saveRDS</code> function in a memory-efficient way, and then you can Slack, email, or share your object, and another person can read it in R with <code>readRDS</code>.
	</p>
	<h4>Installing & Using Packages</h4>
	<p>
		We've now covered a fair amount of base R. We could keep going and learn more, but there are actually packages that accomplish a lot of the things in base R more easily. Next, we will learn how to install and load packages, and then learn about two of the most popular ones: <code>magrittr</code> and <code>stringr</code>.
	</p>
	<p>
		A <strong>package</strong> is an addition to the base libraries in R. Some packages contain multiple smaller packages. Packages are easy to install and quick to load in R.
	</p>
	<h5>Installing Packages</h5>
	<p>
		The first time you use a package, you will need to install it first. Use the <code>install.packages</code> function to do this. Let's install the <code>magrittr</code> and <code>stringr</code> packages.
	</p>
	<pre class="python"><code>install.packages(c("magrittr", "stringr"))</code></pre>
	<p>
		After you've installed it the first time, the package will remain downloaded on your machine. Then, you just need to call <code>library</code> each time you re-open R to use the functions from that package. Let's load up <code>magrittr</code> and <code>stringr</code> for use in the next two sections.
	</p>
	<pre class="python"><code>library(magrittr)</code></pre>
	<pre class="python"><code>library(stringr)</code></pre>
	<h5><code>magrittr</code></h5>
	<p>
		<code>magrittr</code> is a package that allows you to use <strong>piping</strong> in R. Piping is a way to make your code more readable. Essentially, it allows you to compose functions as <code>x %>% g %>% f</code> rather than using <code>f(g(x))</code>. The symbol for pipe is <code>%>%</code>. Since piping reads left-to-right rather than the usual in-to-out, it is more readable and makes your code easier to manage. Furthermore, in <code>magrittr</code> notation, the <code>.</code> symbol is used indicate "what was just passed into the pipe". Therefore, the following are equivalent:
	</p>
	<pre class="python"><code>sqrt(power(123, n = 3))</code></pre>
	<pre class="python"><code># is equiv. to...</code></pre>
	<pre class="python"><code>123 %>% power(n = 3) %>% sqrt</code></pre>
	<pre class="python"><code># is equiv. to</code></pre>
	<pre class="python"><code>3 %>% power(123, n = .) %>% sqrt</code></pre>
	<p>
		You can also use <code>magrittr</code> to use functions rather than the equivalent operator, again making your code easier to read. To view all the aliases, type <code>multiply_by</code> in your R console. Observe the following example:
	</p>
	<pre class="python"><code>(((30 + 6) / 4) %% 3) > 0</code></pre>
	<pre class="python"><code>## is equiv. to...</code></pre>
	<pre class="python"><code>30 %>% add(6) %>% divide_by(4) %>% mod(3) %>% is_greater_than(0)</code></pre>
	<p>
		Finally, you can use <code>magrittr</code> for variable assigment, after running a variable through a lot of functions, using <code>%<>%</code>. Observe the following behaviors:
	</p>
	<pre class="python"><code>a = 64</code></pre>
	<pre class="python"><code>a <- a %>% divide_by(4); print(a)</code></pre>
	<pre class="python"><code># is equiv. to</code></pre>
	<pre class="python"><code>a %>% divide_by(4) -> a; print(a)</code></pre>
	<pre class="python"><code># is equiv. to</code></pre>
	<pre class="python"><code>a %<>% divide_by(4); print(a)</code></pre>

	<h5><code>stringr</code></h5>
	<p>
		<code>stringr</code> is a package used for text and string manipulation in R. We will learn it to gain more familiarity with functions, as well as ease into the <code>tidyverse</code>, which we will learn more about next week.
	</p>
	<h5><code>str_length</code></h5>
	<p>
		<code>stringr</code>'s <code>str_length</code> function returns the number of characters in a string. Observe the following examples:
	</p>
	<pre class="python"><code>x <- "asdf"</code></pre>
	<pre class="python"><code>str_length(x)</code></pre>
	<pre class="python"><code>str_length(c(x, x, "asdfgh"))</code></pre>
	<pre class="python"><code>str_length(NA)</code></pre>
	<h5><code>str_sub</code></h5>
	<p>
		The <code>str_sub</code> function extracts a substring from a string, given a start and end index. Using negative values for the index indicates that you'd like to count the index from the <em>back</em> of the string rather than from the <em>front</em>. Observe the following examples:
	</p>
	<pre class="python"><code>x <- "SUSA is awesome!"</code></pre>
	<pre class="python"><code>x %>% str_sub(start = 2, end = -2)</code></pre>
	<pre class="python"><code>x %>% str_sub(1, 4)</code></pre>
	<pre class="python"><code>x %>% str_sub(3, 3)</code></pre>
	<p>
		We can also use <code>str_sub</code> to edit a substring of a string. Observe the following example:
	</p>
	<pre class="python"><code>str_sub(x, 1, 4) <- "ggplot"</code></pre>
	<pre class="python"><code>x</code></pre>
	<h5><code>str_trim</code></h5>
	<p>
		You can easily <strong>trim</strong> off the whitespace at the beginning or end of a string using <code>str_trim</code>. Observe the following example:
	</p>
	<pre class="python"><code>x <- "    there are unecessary spaces here    "</code></pre>
	<pre class="python"><code>str_length(x)</code></pre>
	<pre class="python"><code>trimmed_x <- str_trim(x); trimmed_x</code></pre>
	<pre class="python"><code>str_length(trimmed_x)</code></pre>

	<h5><code>str_detect</code></h5>
	<p>
		You can search a vector of strings for a search pattern using <code>str_detect</code>. Observe the following example:
	</p>
	<pre class="python"><code>x <- c("Hello world", "#SUSA magic", "#careerexploration", "no hashtags here", "#hashtag"); x</code></pre>
	<pre class="python"><code>str_detect(x, pattern = "#")</code></pre>
	<h5><code>str_replace, str_replace_all</code></h5>
	<p>
		You can replace all the matches to a particular pattern with a replacement pattern using <code>str_replace_all</code>. In contrast, <code>str_replace</code> will only replace the first instance of a pattern per string. Observe the following example:
	</p>
	<pre class="python"><code>x <- c("susa", "pythons suck", "r > python > stata")</code></pre>
	<pre class="python"><code>str_replace(x, pattern = "py", replacement = "mara")</code></pre>
	<pre class="python"><code>str_replace_all(x, pattern = "s", replacement = "S")</code></pre>
	<p>
		This concludes our brief overview of <code>stringr. stringr</code> includes many other very useful functions, so consult the Additional Reading section below if you wish to learn more.
	</p>
	<h4>Sneakpeet at <code>r2</code></h4>
	<p>
		Next week, we will be covering data cleaning and other data science tools in R. You will learn how to <strong>tidy</strong> your data using the <code>tidyverse</code>, a set of packages designed to make data wrangling in R as rapid and painless as possible. tidyverse actually contains <code>stringr</code>, so you're already on your way in learning these tools in R! You will also learn a little bit on how to scrape data from the web.
	</p>
	<br />
	<h4>Additional Reading</h4>
	<ul>
		<li>For a cheatsheet on Base R, visit RStudio's <a href="https://www.rstudio.com/wp-content/uploads/2016/05/base-r.pdf">Base R Cheat Sheet</a>.</li>
		<li>For more information on R Markdown, visit the <a href="https://www.rstudio.com/wp-content/uploads/2015/03/rmarkdown-reference.pdf">R Markdown quick reference guide</a>.</li>
		<li>For a quick intro on the <code>magrittr</code> package, visit the <a href="https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html">magrittr vignette</a>.</li>
		<li>For more information on the <code>stringr</code> text manipulation package, visit the <a href="https://cran.r-project.org/web/packages/stringr/vignettes/stringr.html">stringr vignette</a>.</li>
		<li>For a quick introduction to regex, visit <a href="https://www.maketecheasier.com/the-beginner-guide-to-regular-expressions/">this guide</a>.</li>
		<li>The premier free online textbook for R, written by one of the leading developers of the R ecosystem, <a href="http://r4ds.had.co.nz/">"R for Data Science" can be found here</a>.</li>
		<li>The follow-up textbook to <a href="http://r4ds.had.co.nz/">"R for Data Science"</a>, <a href="http://adv-r.had.co.nz/">"Advanced R", can be found here</a>.</li>
		<li>For a detailed official guide on R, see the first three manuals on <a href="https://cran.cnr.berkeley.edu/manuals.html">this CRAN page</a>.</li>
		<li>For an interactive guide to learning R and Python, visit <a href="https://www.datacamp.com/">DataCamp</a> a paid tutorial website for learning data computing.</li>
	</ul>
</div>

{% endblock %}